<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Temperature Monitor</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns"></script>
    <script src="https://sdk.amazonaws.com/js/aws-sdk-2.1563.0.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .controls-panel {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .control-row {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-weight: 600;
            color: #34495e;
            font-size: 14px;
        }

        input, select, button {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        input[type="file"] {
            padding: 4px;
            background: white;
        }

        button {
            background-color: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #2980b9;
        }

        .btn-success {
            background-color: #27ae60;
        }

        .btn-success:hover {
            background-color: #229954;
        }

        .btn-danger {
            background-color: #e74c3c;
        }

        .btn-danger:hover {
            background-color: #c0392b;
        }

        .btn-secondary {
            background-color: #95a5a6;
        }

        .btn-secondary:hover {
            background-color: #7f8c8d;
        }

        .session-controls {
            border-top: 1px solid #eee;
            padding-top: 15px;
            margin-top: 15px;
        }

        .chart-container {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .chart-wrapper {
            position: relative;
            height: 400px;
            margin-bottom: 20px;
        }

        .legend-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 2px solid #fff;
            box-shadow: 0 0 0 1px #ddd;
        }

        .legend-item input[type="checkbox"] {
            margin: 0;
        }

        .legend-item label {
            margin: 0;
            cursor: pointer;
            font-weight: normal;
        }

        .data-table {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow-x: auto;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }

        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        th {
            background-color: #f8f9fa;
            font-weight: 600;
            color: #2c3e50;
        }

        .delete-btn {
            background-color: #e74c3c;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }

        .delete-btn:hover {
            background-color: #c0392b;
        }

        .status-bar {
            background: #2c3e50;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .alert {
            padding: 10px 15px;
            border-radius: 5px;
            margin-bottom: 15px;
        }

        .alert-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        @media (max-width: 768px) {
            .control-row {
                flex-direction: column;
                align-items: stretch;
            }
            
            .legend-controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Temperature Monitor</h1>
            <p>Record and analyze temperature readings over time</p>
        </div>

        <div class="status-bar">
            <span id="currentSession">Current Session: New Session</span>
            <span id="dataCount">Readings: 0</span>
            <button onclick="signOut()" class="btn-danger" style="margin-left: auto;">Sign Out</button>
        </div>

        <div id="alertContainer"></div>

        <!-- Authentication Panel -->
        <div id="authPanel" class="controls-panel">
            <div class="control-row">
                <h3>Sign In to Temperature Monitor</h3>
            </div>
            <div class="control-row">
                <div class="control-group">
                    <label for="authEmail">Email:</label>
                    <input type="email" id="authEmail" placeholder="your@email.com">
                </div>
                <div class="control-group">
                    <label for="authPassword">Password:</label>
                    <input type="password" id="authPassword" placeholder="Password">
                </div>
                <div class="control-group">
                    <label>&nbsp;</label>
                    <button onclick="signIn()" class="btn-success">Sign In</button>
                </div>
                <div class="control-group">
                    <label>&nbsp;</label>
                    <button onclick="showSignUp()" class="btn-secondary">New User? Sign Up</button>
                </div>
            </div>
            <div id="signUpSection" style="display: none;">
                <div class="control-row">
                    <h4>Create Account</h4>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label for="signUpEmail">Email:</label>
                        <input type="email" id="signUpEmail" placeholder="your@email.com">
                    </div>
                    <div class="control-group">
                        <label for="signUpPassword">Password:</label>
                        <input type="password" id="signUpPassword" placeholder="8+ chars, uppercase, lowercase, number">
                    </div>
                    <div class="control-group">
                        <label>&nbsp;</label>
                        <button onclick="signUp()" class="btn-success">Sign Up</button>
                    </div>
                    <div class="control-group">
                        <label>&nbsp;</label>
                        <button onclick="hideSignUp()" class="btn-secondary">Back to Sign In</button>
                    </div>
                </div>
            </div>
            <div id="verifySection" style="display: none;">
                <div class="control-row">
                    <h4>Verify Your Email</h4>
                    <p>Please check your email and enter the 6-digit verification code:</p>
                </div>
                <div class="control-row">
                    <div class="control-group">
                        <label for="verifyEmail">Email:</label>
                        <input type="email" id="verifyEmail" readonly>
                    </div>
                    <div class="control-group">
                        <label for="verifyCode">Verification Code:</label>
                        <input type="text" id="verifyCode" placeholder="123456" maxlength="6">
                    </div>
                    <div class="control-group">
                        <label>&nbsp;</label>
                        <button onclick="confirmSignUp()" class="btn-success">Verify Account</button>
                    </div>
                    <div class="control-group">
                        <label>&nbsp;</label>
                        <button onclick="resendVerificationCode()" class="btn-secondary">Resend Code</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Application (hidden until authenticated) -->
        <div id="appPanel" style="display: none;" class="controls-panel">
            <div class="control-row">
                <div class="control-group">
                    <label for="sensorName">Sensor Name:</label>
                    <input type="text" id="sensorName" placeholder="e.g., Sensor 1" value="Sensor 1">
                </div>
                <div class="control-group">
                    <label for="temperature" id="temperatureLabel">Temperature (°C):</label>
                    <input type="number" id="temperature" step="0.1" placeholder="0.0">
                </div>
                <div class="control-group">
                    <label for="unitToggle">Unit:</label>
                    <button id="unitToggle" onclick="toggleUnit()" class="btn-secondary">°C / °F</button>
                </div>
                <div class="control-group">
                    <label for="sessionStartInput">Session Start:</label>
                    <input type="datetime-local" id="sessionStartInput">
                </div>
                <div class="control-group">
                    <label for="timeOffset">Time (MM:SS):</label>
                    <input type="text" id="timeOffset" placeholder="00:00" pattern="[0-9]{1,2}:[0-9]{2}">
                </div>
                <div class="control-group">
                    <label>&nbsp;</label>
                    <button onclick="addReading()" class="btn-success">Add Reading</button>
                </div>
            </div>
            
            <div class="session-controls">
                <div class="control-row">
                    <div class="control-group">
                        <label>&nbsp;</label>
                        <button onclick="resetTimeOffset()" class="btn-secondary">Reset Time</button>
                    </div>
                    <div class="control-group">
                        <label for="sessionName">Session Name:</label>
                        <input type="text" id="sessionName" placeholder="Enter session name">
                    </div>
                    <div class="control-group">
                        <label>&nbsp;</label>
                        <button onclick="saveSessionToFile()" class="btn-success">Save to File</button>
                    </div>
                    <div class="control-group">
                        <label>&nbsp;</label>
                        <button onclick="saveSessionToDatabase()" class="btn-success">Save to Database</button>
                    </div>
                    <div class="control-group">
                        <label for="sessionSelect">Load Session:</label>
                        <select id="sessionSelect">
                            <option value="">Select a session...</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>&nbsp;</label>
                        <button onclick="loadSelectedSession()" class="btn-secondary">Load Session</button>
                    </div>
                    <div class="control-group">
                        <label for="fileInput">Load File:</label>
                        <input type="file" id="fileInput" accept=".json" onchange="loadSessionFromFile(event)">
                    </div>
                    <div class="control-group">
                        <label>&nbsp;</label>
                        <button onclick="refreshSessions()" class="btn-secondary">Refresh</button>
                    </div>
                    <div class="control-group">
                        <label>&nbsp;</label>
                        <button onclick="clearData()" class="btn-danger">Clear Data</button>
                    </div>
                </div>
            </div>
        </div>

        <div class="chart-container">
            <h3>Temperature Readings</h3>
            <div class="chart-wrapper">
                <canvas id="temperatureChart"></canvas>
            </div>
            <div class="legend-controls" id="legendControls">
                <!-- Legend items will be populated dynamically -->
            </div>
        </div>

        <div class="data-table">
            <h3>Data Table</h3>
            <table id="dataTable">
                <thead>
                    <tr>
                        <th>Timestamp</th>
                        <th>Sensor</th>
                        <th id="tempHeader">Temperature (°C)</th>
                        <th id="rateHeader">Rate of Rise (°C/min)</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="dataTableBody">
                    <!-- Data rows will be populated dynamically -->
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // Application state
        let temperatureData = {};
        let chart = null;
        let currentSession = 'New Session';
        let currentSessionId = null;
        let visibilitySettings = {};
        let rateOfRiseSettings = {};
        let currentUnit = 'celsius'; // 'celsius' or 'fahrenheit'
        let sessionStartTime = null; // Base time for the session
        
        // API Configuration - Retrieved securely at runtime
        let API_BASE_URL = null;
        let API_ENDPOINTS = null;
        
        // Authentication - Cognito configuration
        let COGNITO_CONFIG = null;
        let cognitoUser = null;
        let cognitoSession = null;
        let idToken = null;
        
        // Load secure configuration
        async function loadSecureConfig() {
            try {
                // Try to load from environment variables or secure endpoint
                const response = await fetch('/api/config');
                if (response.ok) {
                    const config = await response.json();
                    API_BASE_URL = config.apiUrl;
                    
                    // Set up API endpoints
                    API_ENDPOINTS = {
                        storeReading: `${API_BASE_URL}/readings`,
                        getReadings: `${API_BASE_URL}/readings`,
                        listSessions: `${API_BASE_URL}/sessions`
                    };
                    
                    // Set up Cognito configuration
                    COGNITO_CONFIG = {
                        userPoolId: config.userPoolId,
                        clientId: config.userPoolClientId,
                        region: config.cognitoRegion
                    };
                    
                    return config;
                }
            } catch (error) {
                console.warn('Could not load config from server:', error);
            }
            
            // Fallback: prompt user for configuration
            API_BASE_URL = prompt('Please enter your API Gateway URL:');
            const userPoolId = prompt('Please enter your Cognito User Pool ID:');
            const clientId = prompt('Please enter your Cognito Client ID:');
            const region = prompt('Please enter your AWS region:');
            
            if (!API_BASE_URL || !userPoolId || !clientId || !region) {
                showAlert('All configuration values are required for functionality', 'error');
                return null;
            }
            
            // Set up API endpoints
            API_ENDPOINTS = {
                storeReading: `${API_BASE_URL}/readings`,
                getReadings: `${API_BASE_URL}/readings`,
                listSessions: `${API_BASE_URL}/sessions`
            };
            
            // Set up Cognito configuration
            COGNITO_CONFIG = {
                userPoolId: userPoolId,
                clientId: clientId,
                region: region
            };
            
            return { apiUrl: API_BASE_URL, userPoolId, userPoolClientId: clientId, cognitoRegion: region };
        }
        
        // Authentication functions
        function showSignUp() {
            document.getElementById('signUpSection').style.display = 'block';
        }
        
        function hideSignUp() {
            document.getElementById('signUpSection').style.display = 'none';
            document.getElementById('verifySection').style.display = 'none';
        }
        
        async function confirmSignUp() {
            const email = document.getElementById('verifyEmail').value.trim();
            const code = document.getElementById('verifyCode').value.trim();
            
            if (!code) {
                showAlert('Please enter the verification code', 'error');
                return;
            }
            
            if (!COGNITO_CONFIG) {
                showAlert('Cognito configuration not loaded', 'error');
                return;
            }
            
            try {
                AWS.config.region = COGNITO_CONFIG.region;
                const cognitoidentityserviceprovider = new AWS.CognitoIdentityServiceProvider();
                
                const params = {
                    ClientId: COGNITO_CONFIG.clientId,
                    Username: email,
                    ConfirmationCode: code
                };
                
                await cognitoidentityserviceprovider.confirmSignUp(params).promise();
                showAlert('Account verified successfully! You can now sign in.', 'success');
                
                // Hide verification section and show sign in
                document.getElementById('verifySection').style.display = 'none';
                document.getElementById('authEmail').value = email; // Pre-fill email
                
            } catch (error) {
                console.error('Confirmation error:', error);
                
                let errorMessage = 'Verification failed';
                if (error.code) {
                    switch (error.code) {
                        case 'CodeMismatchException':
                            errorMessage = 'Invalid verification code. Please check and try again.';
                            break;
                        case 'ExpiredCodeException':
                            errorMessage = 'Verification code has expired. Please request a new one.';
                            break;
                        case 'NotAuthorizedException':
                            errorMessage = 'User is already confirmed';
                            break;
                        default:
                            errorMessage = `Verification failed: ${error.message}`;
                    }
                } else {
                    errorMessage = `Verification failed: ${error.message}`;
                }
                
                showAlert(errorMessage, 'error');
            }
        }
        
        async function resendVerificationCode() {
            const email = document.getElementById('verifyEmail').value.trim();
            await resendVerificationCodeForEmail(email);
        }
        
        async function resendVerificationCodeForEmail(email) {
            if (!COGNITO_CONFIG) {
                showAlert('Cognito configuration not loaded', 'error');
                return;
            }
            
            try {
                AWS.config.region = COGNITO_CONFIG.region;
                const cognitoidentityserviceprovider = new AWS.CognitoIdentityServiceProvider();
                
                const params = {
                    ClientId: COGNITO_CONFIG.clientId,
                    Username: email
                };
                
                await cognitoidentityserviceprovider.resendConfirmationCode(params).promise();
                showAlert('New verification code sent to your email!', 'success');
                
            } catch (error) {
                console.error('Resend error:', error);
                
                let errorMessage = 'Failed to resend code';
                if (error.code) {
                    switch (error.code) {
                        case 'UserNotFoundException':
                            errorMessage = 'No account found with this email address';
                            break;
                        case 'InvalidParameterException':
                            errorMessage = 'User is already confirmed';
                            break;
                        case 'TooManyRequestsException':
                            errorMessage = 'Too many requests. Please wait before requesting another code';
                            break;
                        default:
                            errorMessage = `Failed to resend code: ${error.message}`;
                    }
                } else {
                    errorMessage = `Failed to resend code: ${error.message}`;
                }
                
                showAlert(errorMessage, 'error');
            }
        }
        
        async function signUp() {
            const email = document.getElementById('signUpEmail').value.trim();
            const password = document.getElementById('signUpPassword').value;
            
            if (!email || !password) {
                showAlert('Please enter email and password', 'error');
                return;
            }
            
            if (!COGNITO_CONFIG) {
                showAlert('Cognito configuration not loaded', 'error');
                return;
            }
            
            try {
                AWS.config.region = COGNITO_CONFIG.region;
                const cognitoidentityserviceprovider = new AWS.CognitoIdentityServiceProvider();
                
                const params = {
                    ClientId: COGNITO_CONFIG.clientId,
                    Username: email,
                    Password: password,
                    UserAttributes: [
                        {
                            Name: 'email',
                            Value: email
                        }
                    ]
                };
                
                await cognitoidentityserviceprovider.signUp(params).promise();
                showAlert('Account created! Please check your email for verification.', 'success');
                
                // Show verification section
                document.getElementById('signUpSection').style.display = 'none';
                document.getElementById('verifySection').style.display = 'block';
                document.getElementById('verifyEmail').value = email;
                
            } catch (error) {
                console.error('Sign up error:', error);
                
                // Parse AWS error messages for better user feedback
                let errorMessage = 'Sign up failed';
                if (error.code) {
                    switch (error.code) {
                        case 'InvalidPasswordException':
                            errorMessage = 'Password must be at least 8 characters with uppercase, lowercase, and numbers';
                            break;
                        case 'UsernameExistsException':
                            // Check if user needs to confirm their account
                            showAlert('Account exists but may need verification. Redirecting to verification...', 'success');
                            document.getElementById('signUpSection').style.display = 'none';
                            document.getElementById('verifySection').style.display = 'block';
                            document.getElementById('verifyEmail').value = email;
                            return;
                        case 'InvalidParameterException':
                            errorMessage = 'Invalid email address format';
                            break;
                        default:
                            errorMessage = `Sign up failed: ${error.message}`;
                    }
                } else {
                    errorMessage = `Sign up failed: ${error.message}`;
                }
                
                showAlert(errorMessage, 'error');
            }
        }
        
        async function signIn() {
            const email = document.getElementById('authEmail').value.trim();
            const password = document.getElementById('authPassword').value;
            
            if (!email || !password) {
                showAlert('Please enter email and password', 'error');
                return;
            }
            
            if (!COGNITO_CONFIG) {
                showAlert('Cognito configuration not loaded', 'error');
                return;
            }
            
            try {
                AWS.config.region = COGNITO_CONFIG.region;
                const cognitoidentityserviceprovider = new AWS.CognitoIdentityServiceProvider();
                
                const params = {
                    AuthFlow: 'USER_PASSWORD_AUTH',
                    ClientId: COGNITO_CONFIG.clientId,
                    AuthParameters: {
                        USERNAME: email,
                        PASSWORD: password
                    }
                };
                
                const result = await cognitoidentityserviceprovider.initiateAuth(params).promise();
                
                if (result.AuthenticationResult) {
                    idToken = result.AuthenticationResult.IdToken;
                    showAlert('Successfully signed in!', 'success');
                    
                    // Hide auth panel and show app
                    document.getElementById('authPanel').style.display = 'none';
                    document.getElementById('appPanel').style.display = 'block';
                    
                    // Initialize the main application
                    await initMainApp();
                    
                } else {
                    showAlert('Authentication failed', 'error');
                }
                
            } catch (error) {
                console.error('Sign in error:', error);
                
                // Parse AWS error messages for better user feedback
                let errorMessage = 'Sign in failed';
                if (error.code) {
                    switch (error.code) {
                        case 'NotAuthorizedException':
                            errorMessage = 'Invalid email or password';
                            break;
                        case 'UserNotConfirmedException':
                            showAlert('Account not verified. Redirecting to verification...', 'success');
                            document.getElementById('authPanel').style.display = 'block';
                            document.getElementById('verifySection').style.display = 'block';
                            document.getElementById('verifyEmail').value = email;
                            // Send a new verification code
                            resendVerificationCodeForEmail(email);
                            return;
                        case 'UserNotFoundException':
                            errorMessage = 'No account found with this email address';
                            break;
                        case 'TooManyRequestsException':
                            errorMessage = 'Too many failed attempts. Please try again later';
                            break;
                        default:
                            errorMessage = `Sign in failed: ${error.message}`;
                    }
                } else {
                    errorMessage = `Sign in failed: ${error.message}`;
                }
                
                showAlert(errorMessage, 'error');
            }
        }
        
        function signOut() {
            idToken = null;
            cognitoUser = null;
            cognitoSession = null;
            
            // Clear application data
            temperatureData = {};
            visibilitySettings = {};
            rateOfRiseSettings = {};
            
            // Show auth panel and hide app
            document.getElementById('authPanel').style.display = 'block';
            document.getElementById('appPanel').style.display = 'none';
            
            showAlert('Signed out successfully', 'success');
        }
        
        // Request configuration
        const REQUEST_CONFIG = {
            timeout: 10000, // 10 seconds
            maxRetries: 3,
            retryDelay: 1000 // 1 second
        };
        
        // Make API request with retry logic
        async function makeAPIRequest(url, options = {}, retries = REQUEST_CONFIG.maxRetries) {
            // Ensure user is authenticated
            if (!idToken) {
                throw new Error('User not authenticated');
            }
            
            try {
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), REQUEST_CONFIG.timeout);
                
                // Add authorization token to headers
                const headers = {
                    'Authorization': `Bearer ${idToken}`,
                    'Content-Type': 'application/json',
                    ...options.headers
                };
                
                const response = await fetch(url, {
                    ...options,
                    headers,
                    signal: controller.signal
                });
                
                clearTimeout(timeoutId);
                
                // Log response details for debugging
                console.log('API Response:', {
                    status: response.status,
                    statusText: response.statusText,
                    url: response.url,
                    ok: response.ok
                });
                
                return response;
                
            } catch (error) {
                console.error(`API request failed (${REQUEST_CONFIG.maxRetries - retries + 1}/${REQUEST_CONFIG.maxRetries}):`, error);
                
                // Handle network errors and timeouts
                if (retries > 0 && (error.name === 'AbortError' || error.name === 'TypeError' || error.name === 'NetworkError')) {
                    console.log(`Retrying in ${REQUEST_CONFIG.retryDelay}ms...`);
                    await new Promise(resolve => setTimeout(resolve, REQUEST_CONFIG.retryDelay));
                    return makeAPIRequest(url, options, retries - 1);
                }
                
                // Create a more descriptive error message
                if (error.name === 'AbortError') {
                    throw new Error('Request timed out');
                } else if (error.name === 'TypeError') {
                    throw new Error('Network error - unable to connect to server');
                } else {
                    throw error;
                }
            }
        }

        // Chart colors for different sensors
        const chartColors = [
            '#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6',
            '#1abc9c', '#34495e', '#e67e22', '#95a5a6', '#d35400'
        ];

        // Initialize the application (called on page load)
        async function init() {
            // Load secure configuration first
            await loadSecureConfig();
            
            // Show authentication panel by default
            document.getElementById('authPanel').style.display = 'block';
            document.getElementById('appPanel').style.display = 'none';
            
            console.log('Application initialized, ready for authentication');
        }
        
        // Initialize the main application (called after authentication)
        async function initMainApp() {
            // Set current session start time
            const now = new Date();
            const localISOTime = new Date(now.getTime() - (now.getTimezoneOffset() * 60000)).toISOString().slice(0, 16);
            document.getElementById('sessionStartInput').value = localISOTime;
            sessionStartTime = new Date(localISOTime);
            
            // Set initial time offset
            document.getElementById('timeOffset').value = '00:00';

            // Initialize chart
            initChart();
            
            // Load available sessions from API
            refreshSessions();
            
            // Create backup of current state
            setInterval(createBackup, 30000); // Backup every 30 seconds if data exists
            
            // Load backup data if exists
            const backupData = localStorage.getItem('temperatureMonitor_backup');
            if (backupData) {
                try {
                    const sessionData = JSON.parse(backupData);
                    if (sessionData.temperatureData && Object.keys(sessionData.temperatureData).length > 0) {
                        loadSessionData(sessionData, 'Recovered Session');
                        showAlert('Previous session recovered', 'success');
                    }
                } catch (error) {
                    console.error('Error loading backup data:', error);
                }
            }
            
            // Add event listener for session start time changes
            document.getElementById('sessionStartInput').addEventListener('change', updateSessionStartTime);
        }

        function initChart() {
            const canvas = document.getElementById('temperatureChart');
            if (!canvas) {
                console.error('Chart canvas not found!');
                return;
            }
            
            const ctx = canvas.getContext('2d');
            console.log('Initializing chart...');
            
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute',
                                displayFormats: {
                                    minute: 'HH:mm',
                                    hour: 'HH:mm'
                                },
                                tooltipFormat: 'HH:mm:ss'
                            },
                            title: {
                                display: true,
                                text: 'Time'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Temperature (°C)'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
        }

        async function addReading() {
            const sensorName = document.getElementById('sensorName').value.trim();
            const temperature = parseFloat(document.getElementById('temperature').value);
            const timeOffsetStr = document.getElementById('timeOffset').value;

            if (!sensorName || isNaN(temperature) || !timeOffsetStr) {
                showAlert('Please fill in all fields', 'error');
                return;
            }

            // Parse time offset (MM:SS format)
            const timeMatch = timeOffsetStr.match(/^(\d{1,2}):(\d{2})$/);
            if (!timeMatch) {
                showAlert('Please enter time in MM:SS format (e.g., 05:30)', 'error');
                return;
            }
            
            const minutes = parseInt(timeMatch[1]);
            const seconds = parseInt(timeMatch[2]);
            
            if (seconds >= 60) {
                showAlert('Seconds must be less than 60', 'error');
                return;
            }
            
            // Convert temperature to Celsius for storage
            const tempInCelsius = currentUnit === 'fahrenheit' ? (temperature - 32) * 5/9 : temperature;
            
            // Calculate actual timestamp
            if (!sessionStartTime) {
                showAlert('Session start time not set', 'error');
                return;
            }
            
            const timestamp = new Date(sessionStartTime);
            timestamp.setMinutes(timestamp.getMinutes() + minutes);
            timestamp.setSeconds(timestamp.getSeconds() + seconds);
            
            
            // Initialize sensor data if it doesn't exist
            if (!temperatureData[sensorName]) {
                temperatureData[sensorName] = [];
                visibilitySettings[sensorName] = true;
                rateOfRiseSettings[sensorName] = false;
            }

            // Add reading (always store in Celsius)
            const newReading = {
                timestamp: timestamp,
                temperature: tempInCelsius,
                rateOfRise: calculateRateOfRise(sensorName, timestamp, tempInCelsius)
            };
            
            console.log('Adding new reading:', newReading);
            
            temperatureData[sensorName].push(newReading);
            
            console.log('Temperature data after adding:', temperatureData);
            
            // Store reading in API
            try {
                await storeReadingInAPI(newReading, sensorName);
            } catch (error) {
                // Fallback: just store locally and continue
                console.error('API failed, storing locally:', error);
                showAlert('Stored locally (API unavailable): ' + error.message, 'success');
            }

            // Sort by timestamp
            temperatureData[sensorName].sort((a, b) => a.timestamp - b.timestamp);

            // Update chart and table
            updateChart();
            updateTable();
            updateLegendControls();
            updateDataCount();

            // Create backup after adding reading
            createBackup();

            // Clear temperature input and update time offset
            document.getElementById('temperature').value = '';
            updateTimeOffset();

            showAlert('Reading added successfully', 'success');
        }

        function calculateRateOfRise(sensorName, currentTime, currentTemp) {
            const sensorData = temperatureData[sensorName];
            if (sensorData.length === 0) return 0;

            const lastReading = sensorData[sensorData.length - 1];
            const timeDiffMinutes = (currentTime - lastReading.timestamp) / (1000 * 60);
            
            if (timeDiffMinutes === 0) return 0;
            
            const tempDiff = currentTemp - lastReading.temperature;
            return Math.round((tempDiff / timeDiffMinutes) * 100) / 100;
        }

        function updateChart() {
            const datasets = [];
            let colorIndex = 0;

            console.log('Updating chart with data:', temperatureData);

            Object.keys(temperatureData).forEach(sensorName => {
                const sensorData = temperatureData[sensorName];
                const color = chartColors[colorIndex % chartColors.length];
                
                console.log(`Processing sensor ${sensorName} with ${sensorData.length} readings`);
                
                // Temperature dataset
                if (visibilitySettings[sensorName]) {
                    const chartData = sensorData.map(reading => ({
                        x: reading.timestamp,
                        y: convertTemperature(reading.temperature, currentUnit)
                    }));
                    
                    console.log(`Chart data for ${sensorName}:`, chartData);
                    
                    datasets.push({
                        label: sensorName,
                        data: chartData,
                        borderColor: color,
                        backgroundColor: color + '20',
                        fill: false,
                        tension: 0.1
                    });
                }

                // Rate of rise dataset
                if (rateOfRiseSettings[sensorName]) {
                    datasets.push({
                        label: sensorName + ' (Rate of Rise)',
                        data: sensorData.map(reading => ({
                            x: reading.timestamp,
                            y: convertRateOfRise(reading.rateOfRise, currentUnit)
                        })),
                        borderColor: color,
                        backgroundColor: color + '20',
                        fill: false,
                        tension: 0.1,
                        borderDash: [5, 5],
                        yAxisID: 'y1'
                    });
                }

                colorIndex++;
            });

            console.log('Final datasets:', datasets);
            
            chart.data.datasets = datasets;
            
            // Update y-axis labels
            const unitSymbol = currentUnit === 'celsius' ? '°C' : '°F';
            chart.options.scales.y.title.text = `Temperature (${unitSymbol})`;
            
            // Add secondary y-axis for rate of rise if needed
            const hasRateOfRise = Object.values(rateOfRiseSettings).some(setting => setting);
            if (hasRateOfRise) {
                chart.options.scales.y1 = {
                    type: 'linear',
                    display: true,
                    position: 'right',
                    title: {
                        display: true,
                        text: `Rate of Rise (${unitSymbol}/min)`
                    },
                    grid: {
                        drawOnChartArea: false,
                    },
                };
            } else {
                delete chart.options.scales.y1;
            }

            console.log('Updating chart...');
            chart.update();
            console.log('Chart updated');
        }

        function updateTable() {
            const tbody = document.getElementById('dataTableBody');
            tbody.innerHTML = '';

            console.log('Updating table with temperature data:', temperatureData);

            const allReadings = [];
            Object.keys(temperatureData).forEach(sensorName => {
                temperatureData[sensorName].forEach((reading, index) => {
                    allReadings.push({
                        ...reading,
                        sensorName: sensorName,
                        sensorIndex: index
                    });
                });
            });

            console.log('All readings for table:', allReadings);

            allReadings.sort((a, b) => b.timestamp - a.timestamp);

            allReadings.forEach(reading => {
                const row = tbody.insertRow();
                const displayTemp = convertTemperature(reading.temperature, currentUnit);
                const displayRate = convertRateOfRise(reading.rateOfRise, currentUnit);
                row.innerHTML = `
                    <td>${reading.timestamp.toLocaleString()}</td>
                    <td>${reading.sensorName}</td>
                    <td>${displayTemp.toFixed(1)}</td>
                    <td>${displayRate.toFixed(2)}</td>
                    <td><button class="delete-btn" onclick="deleteReading('${reading.sensorName}', ${reading.sensorIndex})">Delete</button></td>
                `;
            });
        }

        function updateLegendControls() {
            const container = document.getElementById('legendControls');
            container.innerHTML = '';

            let colorIndex = 0;
            Object.keys(temperatureData).forEach(sensorName => {
                const color = chartColors[colorIndex % chartColors.length];
                
                const legendItem = document.createElement('div');
                legendItem.className = 'legend-item';
                legendItem.innerHTML = `
                    <div class="legend-color" style="background-color: ${color}"></div>
                    <input type="checkbox" id="temp_${sensorName}" 
                           ${visibilitySettings[sensorName] ? 'checked' : ''} 
                           onchange="toggleVisibility('${sensorName}', this.checked)">
                    <label for="temp_${sensorName}">${sensorName}</label>
                    <input type="checkbox" id="rate_${sensorName}" 
                           ${rateOfRiseSettings[sensorName] ? 'checked' : ''} 
                           onchange="toggleRateOfRise('${sensorName}', this.checked)">
                    <label for="rate_${sensorName}">Rate of Rise</label>
                `;
                
                container.appendChild(legendItem);
                colorIndex++;
            });
        }

        function toggleVisibility(sensorName, visible) {
            visibilitySettings[sensorName] = visible;
            updateChart();
        }

        function toggleRateOfRise(sensorName, visible) {
            rateOfRiseSettings[sensorName] = visible;
            updateChart();
        }

        function deleteReading(sensorName, index) {
            if (confirm('Are you sure you want to delete this reading?')) {
                temperatureData[sensorName].splice(index, 1);
                
                if (temperatureData[sensorName].length === 0) {
                    delete temperatureData[sensorName];
                    delete visibilitySettings[sensorName];
                    delete rateOfRiseSettings[sensorName];
                }
                
                updateChart();
                updateTable();
                updateLegendControls();
                updateDataCount();
                showAlert('Reading deleted', 'success');
            }
        }

        async function saveSessionToFile() {
            if (!currentSessionId) {
                showAlert('No active session to save', 'error');
                return;
            }
            
            try {
                // Get all readings for current session from API
                const readings = await loadSessionFromAPI(currentSessionId);
                
                const sessionName = document.getElementById('sessionName').value.trim() || currentSessionId;
                
                const sessionData = {
                    sessionName: sessionName,
                    sessionId: currentSessionId,
                    temperatureData: readings.temperatureData,
                    visibilitySettings: visibilitySettings,
                    rateOfRiseSettings: rateOfRiseSettings,
                    currentUnit: currentUnit,
                    sessionStartTime: sessionStartTime ? sessionStartTime.toISOString() : null,
                    timestamp: new Date().toISOString()
                };

                // Create and download file
                const blob = new Blob([JSON.stringify(sessionData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                a.href = url;
                a.download = `${sessionName}_${timestamp}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                showAlert('Session file saved to downloads', 'success');
                
            } catch (error) {
                console.error('Error saving session:', error);
                showAlert('Failed to save session: ' + error.message, 'error');
            }
        }

        async function saveSessionToDatabase() {
            if (Object.keys(temperatureData).length === 0) {
                showAlert('No data to save to database', 'error');
                return;
            }
            
            try {
                let savedCount = 0;
                let errorCount = 0;
                
                // Get or create session name
                const sessionName = document.getElementById('sessionName').value.trim() || 
                                   currentSessionId || 
                                   generateSessionId();
                
                showAlert('Saving readings to database...', 'success');
                
                // Save each reading to the database
                for (const sensorName of Object.keys(temperatureData)) {
                    for (const reading of temperatureData[sensorName]) {
                        try {
                            await storeReadingInAPI(reading, sensorName, sessionName);
                            savedCount++;
                        } catch (error) {
                            console.error(`Failed to save reading for ${sensorName}:`, error);
                            errorCount++;
                        }
                    }
                }
                
                if (errorCount === 0) {
                    showAlert(`Successfully saved ${savedCount} readings to database`, 'success');
                    // Update current session info
                    if (!currentSessionId) {
                        currentSessionId = sessionName;
                        currentSession = sessionName;
                        document.getElementById('currentSession').textContent = 'Current Session: ' + sessionName;
                    }
                } else {
                    showAlert(`Saved ${savedCount} readings, ${errorCount} failed`, 'error');
                }
                
                // Refresh available sessions
                refreshSessions();
                
            } catch (error) {
                console.error('Error saving session to database:', error);
                showAlert('Failed to save session to database: ' + error.message, 'error');
            }
        }
        
        function autoSaveReading() {
            if (Object.keys(temperatureData).length === 0) {
                showAlert('No data to save', 'error');
                return;
            }
            
            // Auto-save current reading data
            const sessionName = currentSession === 'New Session' ? 'auto_save' : currentSession;
            document.getElementById('sessionName').value = sessionName;
            saveSessionToFile();
        }

        function loadSessionFromFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const sessionData = JSON.parse(e.target.result);
                    loadSessionData(sessionData, sessionData.sessionName || 'Loaded Session');
                    
                    // Set the session ID if available
                    if (sessionData.sessionId) {
                        currentSessionId = sessionData.sessionId;
                    }
                    
                    showAlert('Session loaded successfully', 'success');
                } catch (error) {
                    showAlert('Error loading file: Invalid format', 'error');
                    console.error('Error loading session:', error);
                }
            };
            reader.readAsText(file);
        }
        
        // Load session data from API
        async function loadSessionFromAPI(sessionId) {
            try {
                console.log('Loading session from API:', sessionId);
                
                const response = await makeAPIRequest(`${API_ENDPOINTS.getReadings}?sessionId=${encodeURIComponent(sessionId)}`);
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${errorData.error || response.statusText}`);
                }
                
                const result = await response.json();
                console.log('Session loaded from API:', result);
                
                return result;
                
            } catch (error) {
                console.error('Error loading session from API:', error);
                throw error;
            }
        }
        
        // Load available sessions from API
        async function loadAvailableSessions() {
            try {
                const response = await makeAPIRequest(API_ENDPOINTS.listSessions);
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`API Error: ${errorData.error || response.statusText}`);
                }
                
                const result = await response.json();
                console.log('Available sessions:', result);
                
                return result.sessions || [];
                
            } catch (error) {
                console.error('Error loading available sessions:', error);
                return [];
            }
        }

        // Store reading via API
        async function storeReadingInAPI(reading, sensorName, customSessionId = null) {
            try {
                const payload = {
                    sessionId: customSessionId || currentSessionId || generateSessionId(),
                    sensorName: sensorName,
                    temperature: reading.temperature,
                    rateOfRise: reading.rateOfRise,
                    timestamp: reading.timestamp.toISOString(),
                    unit: currentUnit,
                    sessionStartTime: sessionStartTime ? sessionStartTime.toISOString() : null
                };
                
                console.log('Storing reading via API:', payload);
                
                const response = await makeAPIRequest(API_ENDPOINTS.storeReading, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    let errorMessage = `HTTP ${response.status}: ${response.statusText}`;
                    try {
                        const errorData = await response.json();
                        errorMessage = errorData.error || errorData.message || errorMessage;
                    } catch (e) {
                        // If we can't parse error response, use status text
                        console.log('Could not parse error response:', e);
                    }
                    throw new Error(errorMessage);
                }
                
                const result = await response.json();
                console.log('Reading stored successfully:', result);
                
                // Update currentSessionId if this was the first reading
                if (!currentSessionId) {
                    currentSessionId = payload.sessionId;
                    currentSession = payload.sessionId;
                    document.getElementById('currentSession').textContent = 'Current Session: ' + currentSession;
                }
                
            } catch (error) {
                console.error('Error storing reading:', error);
                showAlert('Failed to store reading: ' + error.message, 'error');
                
                // Fallback to localStorage as backup
                saveReadingToLocalStorage(reading, sensorName);
            }
        }
        
        // Fallback storage to localStorage
        function saveReadingToLocalStorage(reading, sensorName) {
            const logEntry = {
                timestamp: new Date().toISOString(),
                sessionName: currentSession,
                sensorName: sensorName,
                reading: reading
            };
            
            const existingLog = JSON.parse(localStorage.getItem('temperatureLog') || '[]');
            existingLog.push(logEntry);
            localStorage.setItem('temperatureLog', JSON.stringify(existingLog));
            
            showAlert('Reading saved locally (API unavailable)', 'success');
        }
        
        // Generate unique session ID
        function generateSessionId() {
            const timestamp = new Date().toISOString().slice(0, 19).replace(/[:-]/g, '');
            const random = Math.random().toString(36).substring(2, 8);
            return `session_${timestamp}_${random}`;
        }

        function loadSessionData(sessionData, sessionName) {
            // Convert timestamp strings back to Date objects
            Object.keys(sessionData.temperatureData).forEach(sensorName => {
                sessionData.temperatureData[sensorName].forEach(reading => {
                    reading.timestamp = new Date(reading.timestamp);
                });
            });

            temperatureData = sessionData.temperatureData || {};
            visibilitySettings = sessionData.visibilitySettings || {};
            rateOfRiseSettings = sessionData.rateOfRiseSettings || {};
            currentUnit = sessionData.currentUnit || 'celsius';
            
            // Restore session start time
            if (sessionData.sessionStartTime) {
                sessionStartTime = new Date(sessionData.sessionStartTime);
                const localISOTime = new Date(sessionStartTime.getTime() - (sessionStartTime.getTimezoneOffset() * 60000)).toISOString().slice(0, 16);
                document.getElementById('sessionStartInput').value = localISOTime;
            }
            
            currentSession = sessionName;
            document.getElementById('currentSession').textContent = 'Current Session: ' + sessionName;
            
            updateChart();
            updateTable();
            updateLegendControls();
            updateDataCount();
            updateUnitLabels();
            
            // Create backup after loading
            createBackup();
        }

        function clearData() {
            if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
                temperatureData = {};
                visibilitySettings = {};
                rateOfRiseSettings = {};
                currentUnit = 'celsius';
                currentSession = 'New Session';
                currentSessionId = null;
                
                // Reset session start time
                const now = new Date();
                const localISOTime = new Date(now.getTime() - (now.getTimezoneOffset() * 60000)).toISOString().slice(0, 16);
                document.getElementById('sessionStartInput').value = localISOTime;
                sessionStartTime = new Date(localISOTime);
                document.getElementById('timeOffset').value = '00:00';
                
                document.getElementById('currentSession').textContent = 'Current Session: New Session';
                
                updateChart();
                updateTable();
                updateLegendControls();
                updateDataCount();
                
                showAlert('Data cleared', 'success');
            }
        }

        function updateSessionStartTime() {
            const sessionStartStr = document.getElementById('sessionStartInput').value;
            if (sessionStartStr) {
                sessionStartTime = new Date(sessionStartStr);
            }
        }
        
        function updateTimeOffset() {
            // Auto-increment time offset by 30 seconds for convenience
            const currentOffset = document.getElementById('timeOffset').value;
            const timeMatch = currentOffset.match(/^(\d{1,2}):(\d{2})$/);
            
            if (timeMatch) {
                let minutes = parseInt(timeMatch[1]);
                let seconds = parseInt(timeMatch[2]) + 30;
                
                if (seconds >= 60) {
                    minutes += Math.floor(seconds / 60);
                    seconds = seconds % 60;
                }
                
                const newOffset = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                document.getElementById('timeOffset').value = newOffset;
            }
        }

        function updateDataCount() {
            let totalReadings = 0;
            Object.keys(temperatureData).forEach(sensorName => {
                totalReadings += temperatureData[sensorName].length;
            });
            document.getElementById('dataCount').textContent = 'Readings: ' + totalReadings;
        }

        function showAlert(message, type) {
            const container = document.getElementById('alertContainer');
            const alert = document.createElement('div');
            alert.className = `alert alert-${type}`;
            alert.textContent = message;
            
            container.appendChild(alert);
            
            setTimeout(() => {
                container.removeChild(alert);
            }, 3000);
        }

        // Temperature conversion functions
        function convertTemperature(tempInCelsius, targetUnit) {
            if (targetUnit === 'fahrenheit') {
                return (tempInCelsius * 9/5) + 32;
            }
            return tempInCelsius;
        }

        function convertRateOfRise(rateInCelsius, targetUnit) {
            if (targetUnit === 'fahrenheit') {
                return rateInCelsius * 9/5;
            }
            return rateInCelsius;
        }

        // Refresh available sessions
        async function refreshSessions() {
            try {
                const sessions = await loadAvailableSessions();
                const select = document.getElementById('sessionSelect');
                
                // Clear existing options
                select.innerHTML = '<option value="">Select a session...</option>';
                
                // Add session options
                sessions.forEach(session => {
                    const option = document.createElement('option');
                    option.value = session.sessionId;
                    option.textContent = `${session.sessionId} (${session.readingCount} readings, ${session.sensorCount} sensors)`;
                    select.appendChild(option);
                });
                
                console.log(`Loaded ${sessions.length} available sessions`);
                
            } catch (error) {
                console.error('Error refreshing sessions:', error);
                showAlert('Failed to load available sessions', 'error');
            }
        }
        
        // Load selected session
        async function loadSelectedSession() {
            const sessionId = document.getElementById('sessionSelect').value;
            if (!sessionId) {
                showAlert('Please select a session to load', 'error');
                return;
            }
            
            try {
                const sessionData = await loadSessionFromAPI(sessionId);
                
                // Convert the API response to the format expected by loadSessionData
                const formattedData = {
                    temperatureData: {},
                    sessionStartTime: sessionData.sessionMetadata?.sessionStartTime,
                    currentUnit: sessionData.sessionMetadata?.unit || 'celsius'
                };
                
                // Convert API format to internal format
                Object.keys(sessionData.temperatureData).forEach(sensorName => {
                    formattedData.temperatureData[sensorName] = sessionData.temperatureData[sensorName].map(reading => ({
                        ...reading,
                        timestamp: new Date(reading.timestamp)
                    }));
                });
                
                loadSessionData(formattedData, sessionId);
                currentSessionId = sessionId;
                
                showAlert('Session loaded successfully', 'success');
                
            } catch (error) {
                console.error('Error loading selected session:', error);
                showAlert('Failed to load session: ' + error.message, 'error');
            }
        }
        
        function createBackup() {
            if (Object.keys(temperatureData).length > 0) {
                const backupData = {
                    temperatureData: temperatureData,
                    visibilitySettings: visibilitySettings,
                    rateOfRiseSettings: rateOfRiseSettings,
                    currentUnit: currentUnit,
                    sessionStartTime: sessionStartTime ? sessionStartTime.toISOString() : null,
                    currentSessionId: currentSessionId,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('temperatureMonitor_backup', JSON.stringify(backupData));
            }
        }
        
        function resetTimeOffset() {
            document.getElementById('timeOffset').value = '00:00';
            showAlert('Time offset reset to 00:00', 'success');
        }
        
        function updateUnitLabels() {
            const unitSymbol = currentUnit === 'celsius' ? '°C' : '°F';
            document.getElementById('temperatureLabel').textContent = `Temperature (${unitSymbol}):`;
            document.getElementById('tempHeader').textContent = `Temperature (${unitSymbol})`;
            document.getElementById('rateHeader').textContent = `Rate of Rise (${unitSymbol}/min)`;
        }

        function toggleUnit() {
            currentUnit = currentUnit === 'celsius' ? 'fahrenheit' : 'celsius';
            
            // Update UI labels
            updateUnitLabels();
            
            // Convert current input value if there is one
            const tempInput = document.getElementById('temperature');
            if (tempInput.value !== '') {
                const currentValue = parseFloat(tempInput.value);
                if (!isNaN(currentValue)) {
                    if (currentUnit === 'fahrenheit') {
                        // Converting from Celsius to Fahrenheit
                        tempInput.value = ((currentValue * 9/5) + 32).toFixed(1);
                    } else {
                        // Converting from Fahrenheit to Celsius
                        tempInput.value = ((currentValue - 32) * 5/9).toFixed(1);
                    }
                }
            }
            
            // Update chart and table
            updateChart();
            updateTable();
            
            showAlert(`Switched to ${currentUnit === 'celsius' ? 'Celsius' : 'Fahrenheit'}`, 'success');
            
            // Create backup after unit change
            createBackup();
        }

        // Initialize the application when the page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
